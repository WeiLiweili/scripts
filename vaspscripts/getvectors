#! /usr/bin/env python

""" 
script which takes lattice vectors in real space [a = (a1,a2,a3), b = (b1,b2,b3) and c = (c1,c2,c3)] 
and returns real space lattice vector lengths / volume and reciprocol lattice vectors / lengths. 
If a high symmetry point in reciprocol space is provided in fractional coordinates the distance to this 
high symmetry point will also be calculated. If k point density is also provided the number of k points
required to sample gamma to the high symmetry point at this density is calculated. If the number of 
k points is provided the sampling density is calculated. This can be used in conjunction with Keith's
code (location here) to calculate a band structure route through the Brillouin zone.
TODO: Include numpy.asarray to convert argparse list output into array.
"""

import numpy
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('real_lattice_vectors', action='store', type=float, 
                    help='<required> lattice vectors in real space: a1 a2 a3 b1 b2 b3 c1 c2 c3',
                    nargs=9)
parser.add_argument('-p', '--high_symmetry_point', action='store', type=float,
                    help="""<optional> position of high symmetry point fractional coordinate 
                    in k-space, eg: 0 0.5 0. If provided the distance from gamma to 
                    high_symmetry_point in units of 1/Angstrom will be calculated.'""",
                    nargs=3, dest='high_symmetry_point', required=False)
parser.add_argument('-d', '--sampling_decimal', action='store', type=float,
                    help="""<optional> the k point sampling density required 
                    in units per 1/Angstrom. If high_symmetry_point is provided the 
                    number of k points needed to achieve this density from gamma to 
                    high_symmetry_point will be calculated.""",
                    nargs=1, dest='sampling_decimal', required=False)
parser.add_argument('-n', '--number_kpoints', action='store', type=int,
                   help="""<optional> the number of k points between gamma and 
                   high_symmetry_point. If high_symmetry_point is provided the 
                   k point sampling density will be calculated""",
                   nargs=1, dest='number_kpoints', required=False)
parser.add_argument('-s', '--scale', action='store', type=float,
                    help="<optional> scales lattice vectors by given amount",
                    nargs=1, dest='scaling', required=False)
args = parser.parse_args()

numpy.set_printoptions(suppress=True) # to stop scientific notation

def vector_length(array):
    length =  numpy.sqrt((array[0]**2)+(array[1]**2)+(array[2]**2))
    return length

a = numpy.array([args.real_lattice_vectors[0], args.real_lattice_vectors[1], args.real_lattice_vectors[2]])
b = numpy.array([args.real_lattice_vectors[3], args.real_lattice_vectors[4], args.real_lattice_vectors[5]])
c = numpy.array([args.real_lattice_vectors[6], args.real_lattice_vectors[7], args.real_lattice_vectors[8]])

if args.scaling is not None:
    a,b,c = a*args.scaling[0], b*args.scaling[0], c*args.scaling[0]

a_length, b_length, c_length = vector_length(a), vector_length(b), vector_length(c)

volume = numpy.dot(a, numpy.cross(b, c))

a_star = 2*numpy.pi*numpy.cross(b,c) / volume
b_star = 2*numpy.pi*numpy.cross(c,a) / volume
c_star = 2*numpy.pi*numpy.cross(a,b) / volume

a_star_check = 2*numpy.pi / a_length
print (a_star_check)
a_star_length, b_star_length, c_star_length = vector_length(a_star), vector_length(b_star), vector_length(c_star)

"""reciprocal lengths could be taken as 1/(real space vector lengths) but we would not have complete information
about the reciprocal vectors. Could be built in as an assert statement. """

print ("\nLattice vector a = %s has length %0.8f Angstrom." % (a, a_length))
print ("Lattice vector b = %s has length %0.8f Angstrom." % (b, b_length))
print ("Lattice vector c = %s has length %0.8f Angstrom.\n" % (c, c_length))
print ("Reciprocal lattice vector a* = %s has length %0.8f 1/Angstrom." % (a_star, a_star_length))
print ("Reciprocal lattice vector b* = %s has length %0.8f 1/Angstrom." % (b_star, b_star_length))
print ("Reciprocal lattice vector c* = %s has length %0.8f 1/Angstrom.\n" % (c_star, c_star_length))

if args.high_symmetry_point is not None:
    distance = numpy.sqrt(((args.high_symmetry_point[0]*a_star_length)**2)+((args.high_symmetry_point[1]*b_star_length)**2)
               + ((args.high_symmetry_point[2]*c_star_length)**2))
    print ("Distance to high symmetry point is %0.8f 1/Angstrom. \n" % distance )
    
    if args.sampling_decimal is not None:
        number = (1/args.sampling_decimal[0])*distance
        print ("To achieve a sampling every %0.4f 1/Angstrom across the band section length (gamma to high symmetry point %s you require  %0.1f k-points. \n" % (args.sampling_decimal[0], args.high_symmetry_point, number))

    if args.number_kpoints is not None:
        sampling = distance / args.number_kpoints[0]
        print ("%d k-points between gamma and high symmetry point %s gives a sampling every %0.3f 1/Angstrom\n"
        % (args.number_kpoints[0], args.high_symmetry_point, sampling))
