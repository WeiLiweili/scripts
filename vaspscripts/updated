#! /usr/bin/env python

""" 
script which takes lattice vectors in real space [a = (a1,a2,a3), b = (b1,b2,b3) and c = (c1,c2,c3)] 
and returns real space lattice vector lengths / volume and reciprocol lattice vectors / lengths. 
If a high symmetry point in reciprocol space is provided in fractional coordinates the distance to this 
high symmetry point will also be calculated. If k point density is also provided the number of k points
required to sample gamma to the high symmetry point at this density is calculated. If the number of 
k points is provided the sampling density is calculated. This can be used in conjunction with Keith's
code (location here) to calculate a band structure route through the Brillouin zone.
TODO: Include numpy.asarray to convert argparse list output into array.
"""

import numpy
import argparse

numpy.set_printoptions(suppress=True) # to stop scientific notation

class SpaceTools(self):
    def __init__:
        values = {'a': None,
                  'b': None,
                  'c': None,
                  'a_star': None,
                  'b_star': None,
                  'c_star': None,
                  'a_length': None,
                  'b_length': None,
                  'c_length': None,
                  'a_star_length': None,
                  'b_star_length': None,
                  'c_star_length': None,
        }

    def vector_length(array):
        length =  numpy.sqrt((array[0]**2)+(array[1]**2)+(array[2]**2))
        return length

    def real_to_reciprocal(a, b, c, scaling=1):
        a,b,c = a*args.scaling, b*args.scaling, c*args.scaling
        a_length, b_length, c_length = vector_length(a), vector_length(b), 
                                       vector_length(c)
        volume = numpy.dot(a, numpy.cross(b, c))
        a_star = 2*numpy.pi*numpy.cross(b,c) / volume
        b_star = 2*numpy.pi*numpy.cross(c,a) / volume
        c_star = 2*numpy.pi*numpy.cross(a,b) / volume
        # reciprocal lengths can also be calc'd with 2*pi/a etc
        a_star_length, b_star_length, c_star_length = vector_length(a_star), 
                                                      vector_length(b_star), 
                                                      vector_length(c_star)
        print_to_screen(a, b, c, a_length, b_length, c_length, 
                        a_star, b_star, c_star, a_star_length, b_star_length,
                        c_star_length)

    def reciprocal_to_real(a_star, b_star, c_star):





a = numpy.array([args.real_lattice_vectors[0], args.real_lattice_vectors[1], 
                args.real_lattice_vectors[2]])
b = numpy.array([args.real_lattice_vectors[3], args.real_lattice_vectors[4], 
                args.real_lattice_vectors[5]])
c = numpy.array([args.real_lattice_vectors[6], args.real_lattice_vectors[7], 
                 args.real_lattice_vectors[8]])

space = space_tools.SpaceTools()
real_to_reciprocal(a, b, c, scaling=args.scaling)

def print_to_screen(
print ("\nLattice vector a = %s has length %0.8f Angstrom." % (a, a_length))
print ("Lattice vector b = %s has length %0.8f Angstrom." % (b, b_length))
print ("Lattice vector c = %s has length %0.8f Angstrom.\n" % (c, c_length))
print ("Reciprocal lattice vector a* = %s has length %0.8f 1/Angstrom." % (a_star, a_star_length))
print ("Reciprocal lattice vector b* = %s has length %0.8f 1/Angstrom." % (b_star, b_star_length))
print ("Reciprocal lattice vector c* = %s has length %0.8f 1/Angstrom.\n" % (c_star, c_star_length))

if args.high_symmetry_point is not None:
    distance = numpy.sqrt(((args.high_symmetry_point[0]*a_star_length)**2)+((args.high_symmetry_point[1]*b_star_length)**2)
               + ((args.high_symmetry_point[2]*c_star_length)**2))
    print ("Distance to high symmetry point is %0.8f 1/Angstrom. \n" % distance )
    
    if args.sampling_decimal is not None:
        number = (1/args.sampling_decimal[0])*distance
        print ("To achieve a sampling every %0.4f 1/Angstrom across the band section length (gamma to high symmetry point %s you require  %0.1f k-points. \n" % (args.sampling_decimal[0], args.high_symmetry_point, number))

    if args.number_kpoints is not None:
        sampling = distance / args.number_kpoints[0]
        print ("%d k-points between gamma and high symmetry point %s gives a sampling every %0.3f 1/Angstrom\n"
        % (args.number_kpoints[0], args.high_symmetry_point, sampling))

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('lattice_vectors', type=float, required=True,
                        help='<required> lattice vectors in real space: a1 a2 a3 b1 b2 b3 c1 c2 c3',
                        nargs=9)
    parser.add_argument('-p', '--high_symmetry_point', action='store', type=float,
                        help="""<optional> position of high symmetry point fractional coordinate 
                        in k-space, eg: 0 0.5 0. If provided the distance from gamma to 
                        high_symmetry_point in units of 1/Angstrom will be calculated.'""",
                        nargs=3, dest='high_symmetry_point', required=False)
    parser.add_argument('-d', '--sampling_decimal', action='store', type=float,
                        help="""<optional> the k point sampling density required 
                        in units per 1/Angstrom. If high_symmetry_point is provided the 
                        number of k points needed to achieve this density from gamma to 
                        high_symmetry_point will be calculated.""",
                        nargs=1, dest='sampling_decimal', required=False)
    parser.add_argument('-n', '--number_kpoints', type=int,
                       help="<optional> the number of k points between gamma and" 
                       "high_symmetry_point. If high_symmetry_point is provided"
                       "the k point sampling density will be calculated",
                       nargs=1, required=False)
    parser.add_argument('-s', '--scaling', type=float,
                        help="<optional> scales lattice vectors by given amount"
                        "(defalt: 1)", default=1, nargs=1, required=False)
    args = parser.parse_args()


